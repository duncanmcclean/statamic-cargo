<template>
    <div>
        <breadcrumb v-if="breadcrumbs" :url="breadcrumbs[0].url" :title="breadcrumbs[0].text" />

        <div class="mb-6 flex items-center">
            <h1 class="flex-1">
                <div class="flex items-center">
                    <span v-html="formattedTitle" />
                </div>
            </h1>

            <div class="hidden items-center md:flex">
                <save-button-options
                    v-if="!readOnly"
                    :show-options="!isInline"
                    button-class="btn-primary"
                    :preferences-prefix="preferencesPrefix"
                >
                    <button class="btn-primary" :disabled="!canSave" @click.prevent="save" v-text="`Save`" />
                </save-button-options>
            </div>

            <slot name="action-buttons-right" />
        </div>

        <publish-container
            v-if="fieldset"
            ref="container"
            :name="publishContainer"
            :blueprint="fieldset"
            :values="values"
            :reference="initialReference"
            :meta="meta"
            :errors="errors"
            :track-dirty-state="trackDirtyState"
            @updated="values = $event"
            v-slot="{ container, components, setFieldMeta }"
        >
            <div>
                <component
                    v-for="component in components"
                    :key="component.id"
                    :is="component.name"
                    :container="container"
                    v-bind="component.props"
                    v-on="component.events"
                />

                <publish-tabs
                    v-show="tabsVisible"
                    :read-only="readOnly"
                    :enable-sidebar="false"
                    @updated="setFieldValue"
                    @meta-updated="setFieldMeta"
                    @focus="container.$emit('focus', $event)"
                    @blur="container.$emit('blur', $event)"
                ></publish-tabs>
            </div>
        </publish-container>

        <div class="mt-6 flex items-center md:hidden">
            <button v-if="!readOnly" class="btn-lg btn-primary w-full" :disabled="!canSave" @click.prevent="save">
                {{ __('Save') }}
            </button>
        </div>
    </div>
</template>

<script>
import SaveButtonOptions from '@statamic/components/publish/SaveButtonOptions.vue';
import HasPreferences from '@statamic/components/data-list/HasPreferences.js';
import HasHiddenFields from '@statamic/components/publish/HasHiddenFields.js';
import HasActions from '@statamic/components/publish/HasActions.js';
import clone from '@statamic/util/clone.js';
import striptags from 'striptags';

export default {
    mixins: [HasPreferences, HasHiddenFields, HasActions],

    components: {
        SaveButtonOptions,
    },

    props: {
        publishContainer: String,
        initialReference: String,
        initialFieldset: Object,
        initialValues: Object,
        initialMeta: Object,
        initialTitle: String,
        initialReadOnly: Boolean,
        breadcrumbs: Array,
        initialActions: Object,
        method: String,
        isCreating: Boolean,
        isInline: Boolean,
        createAnotherUrl: String,
        initialListingUrl: String,
    },

    data() {
        return {
            actions: this.initialActions,
            saving: false,
            trackDirtyState: true,
            fieldset: this.initialFieldset,
            title: this.initialTitle,
            values: clone(this.initialValues),
            meta: clone(this.initialMeta),
            error: null,
            errors: {},
            tabsVisible: true,
            state: 'new',
            preferencesPrefix: `cargo.tax-classes`,
            readOnly: this.initialReadOnly,

            saveKeyBinding: null,
            quickSaveKeyBinding: null,
            quickSave: false,
        };
    },

    computed: {
        store() {
            return this.$refs.container.store;
        },

        formattedTitle() {
            return striptags(__(this.title));
        },

        hasErrors() {
            return this.error || Object.keys(this.errors).length;
        },

        somethingIsLoading() {
            return !this.$progress.isComplete();
        },

        canSave() {
            return !this.readOnly && !this.somethingIsLoading;
        },

        listingUrl() {
            return `${this.initialListingUrl}`;
        },

        isBase() {
            return this.publishContainer === 'base';
        },

        isDirty() {
            return this.$dirty.has(this.publishContainer);
        },

        afterSaveOption() {
            return this.getPreference('after_save');
        },

        direction() {
            return this.$config.get('direction', 'ltr');
        },
    },

    watch: {
        saving(saving) {
            this.$progress.loading(`${this.publishContainer}-coupon-publish-form`, saving);
        },
    },

    methods: {
        clearErrors() {
            this.error = null;
            this.errors = {};
        },

        save() {
            if (!this.canSave) {
                this.quickSave = false;
                return;
            }

            this.saving = true;
            this.clearErrors();

            setTimeout(() => this.runBeforeSaveHook(), 151); // 150ms is the debounce time for fieldtype updates
        },

        runBeforeSaveHook() {
            this.$refs.container.saving();

            Statamic.$hooks
                .run('tax-class.saving', {
                    values: this.values,
                    container: this.$refs.container,
                    storeName: this.publishContainer,
                })
                .then(this.performSaveRequest)
                .catch((error) => {
                    this.saving = false;
                    this.$toast.error(error || 'Something went wrong');
                });
        },

        performSaveRequest() {
            this.$axios[this.method](this.actions.save, this.visibleValues)
                .then((response) => {
                    this.saving = false;
                    if (!response.data.saved) {
                        return this.$toast.error(__(`Couldn't save tax class`));
                    }
                    this.title = response.data.data.title;
                    this.$toast.success(__('Saved'));
                    this.$refs.container.saved();
                    this.runAfterSaveHook(response);
                })
                .catch((error) => this.handleAxiosError(error));
        },

        runAfterSaveHook(response) {
            // Once the save request has completed, we want to run the "after" hook.
            // Devs can do what they need and we'll wait for them, but they can't cancel anything.
            Statamic.$hooks
                .run('tax-class.saved', {
                    reference: this.initialReference,
                    response,
                })
                .then(() => {
                    let nextAction = this.quickSave ? 'continue_editing' : this.afterSaveOption;

                    // If the user has opted to create another tax class, redirect them to create page.
                    if (!this.isInline && nextAction === 'create_another') {
                        window.location = this.createAnotherUrl;
                    }

                    // If the user has opted to go to listing (default/null option), redirect them there.
                    else if (!this.isInline && nextAction === null) {
                        window.location = this.listingUrl;
                    }

                    // Otherwise, leave them on the edit form and emit an event. We need to wait until after
                    // the hooks are resolved because if this form is being shown in a stack, we only
                    // want to close it once everything's done.
                    else {
                        clearTimeout(this.trackDirtyStateTimeout);
                        this.trackDirtyState = false;
                        this.values = this.resetValuesFromResponse(response.data.data.values);
                        this.trackDirtyStateTimeout = setTimeout(() => (this.trackDirtyState = true), 350);
                        this.$nextTick(() => this.$emit('saved', response));
                    }

                    this.quickSave = false;
                })
                .catch((e) => console.error(e));
        },

        handleAxiosError(e) {
            this.saving = false;
            if (e.response && e.response.status === 422) {
                const { message, errors } = e.response.data;
                this.error = message;
                this.errors = errors;
                this.$toast.error(message);
                this.$reveal.invalid();
            } else if (e.response) {
                this.$toast.error(e.response.data.message);
            } else {
                this.$toast.error(e || 'Something went wrong');
            }
        },

        setFieldValue(handle, value) {
            this.$refs.container.setFieldValue(handle, value);
        },

        afterActionSuccessfullyCompleted(response) {
            if (response.data) {
                this.title = response.data.title;
                this.values = this.resetValuesFromResponse(response.data.values);
                this.itemActions = response.data.itemActions;
            }
        },
    },

    mounted() {
        this.$nextTick(() => {
            document.getElementById('field_name').focus();
        });

        this.saveKeyBinding = this.$keys.bindGlobal(['mod+return'], (e) => {
            e.preventDefault();
            this.save();
        });

        this.quickSaveKeyBinding = this.$keys.bindGlobal(['mod+s'], (e) => {
            e.preventDefault();
            this.quickSave = true;
            this.save();
        });
    },

    created() {
        window.history.replaceState({}, document.title, document.location.href.replace('created=true', ''));
    },

    unmounted() {
        clearTimeout(this.trackDirtyStateTimeout);
    },

    destroyed() {
        this.saveKeyBinding.destroy();
        this.quickSaveKeyBinding.destroy();
    },
};
</script>
